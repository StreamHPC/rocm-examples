// MIT License
//
// Copyright (c) 2024 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "example_utils.hpp"
#include "rocrand_utils.hpp"

#include <hip/hip_runtime.h>
#include <rocrand/rocrand_kernel.h>
#include <rocrand/rocrand_mtgp32_11213.h>

#include <iostream>
#include <vector>

///
/// \brief Cooperative generation of \p size uniformly distributed random <tt>unsigned int</tt> among thread blocks.
///
/// Each thread generates as many values as necessary. For instance:
/// - if \p size = gridDim.x * blockDim.x, where gridDim.x * blockDim.x is the total number of
///   threads, each thread generates one output value.
/// - if \p size is not a multiple of gridDim.x * blockDim.x, then thread i within block j will generate
///   size / (gridDim.x * blockDim.x) + ((j * blockDim.x + i) < (size % (gridDim.x * blockDim.x)))
///   output values, where:
///   - size / (gridDim.x * blockDim.x) tells how many values do all threads generate
///   - j * blockDim.x + i is the global index of thread i within block j
///   - size % (gridDim.x * blockDim.x) is the amount of extra values to be generated which is not a multiple of the
///     total number of threads
/// For instance, in this example we launch the generation kernels with a total of 4*64 = 256 threads, but we need to
/// generate 1000 values. Each thread will generate 3 values and threads from 0 to 231 will generate 1 extra value.
///
/// \tparam StateT Pseudorandom generator state type.
///
/// \param output Global memory output buffer.
/// \param size Amount of values to be generated by each thread.
/// \param seed Seed value.
/// \param offset Values to skip from the generated sequence.
///
template<class StateT>
__global__ void rocrand_kernel(unsigned int*            output,
                               const size_t             size,
                               const unsigned long long seed   = 0,
                               const unsigned long long offset = 0)
{
    const unsigned int tid    = blockIdx.x * blockDim.x + threadIdx.x;
    const unsigned int stride = gridDim.x * blockDim.x;

    StateT             state;
    const unsigned int subsequence = tid;
    rocrand_init(seed, subsequence, offset, &state);

    unsigned int index = tid;
    while(index < size)
    {
        output[index] = rocrand(&state);
        index += stride;
    }
}

///
/// \brief Cooperative generation of \p size uniformly distributed random <tt>unsigned int</tt> with MTGP32.
///
/// The MTGP32 generator can produce values for several sequences at the same time, thus needing to update
/// multiple states.
/// In this example, each block takes care of generating values for one of said sequences:
/// - the state to be updated is loaded from global memory before starting to generate values,
/// - threads in the block generate as many values are needed,
/// - the state is saved back to global memory after the generation is done.
///
/// \tparam StateT MTGP32 generator state type.
///
/// \param states Generators' states.
/// \param output Global memory output buffer.
/// \param size Amount of values to be generated by each thread.
///
template<class StateT>
__global__ void mtgp32_rocrand_kernel(StateT* states, unsigned int* output, const size_t size)
{
    const unsigned int state_id = blockIdx.x;
    unsigned int       index    = blockIdx.x * blockDim.x + threadIdx.x;
    unsigned int       stride   = gridDim.x * blockDim.x;

    // Generator state is shared among the threads of a block.
    __shared__ StateT state;

    // Cooperatively copy current generator's state to shared state.
    rocrand_mtgp32_block_copy(&states[state_id], &state);

    // Generate values. Only write to the output the ones within the original size.
    const size_t remainder       = size % blockDim.x;
    const size_t size_rounded_up = (remainder == 0) ? size : size + (blockDim.x - remainder);
    while(index < size_rounded_up)
    {
        auto value = rocrand(&state);
        if(index < size)
        {
            output[index] = value;
        }
        index += stride;
    }

    // Cooperatively save generator's state.
    rocrand_mtgp32_block_copy(&state, &states[state_id]);
}

///
/// \brief Cooperative generation of \p size uniformly distributed random <tt>unsigned int</tt> with LFSR113.
///
/// The LFSR113 generator is a combined LFSR generator that uses four LFSR recurrences to produce
/// random values. These recurrences need an initial seed each, thus the \p seed parameter for
/// \p rocrand_init must have 4 components.
///
/// \tparam StateT Pseudorandom generator state type.
///
/// \param output Global memory output buffer.
/// \param size Amount of values to be generated by each thread.
/// \param seed Seed value.
///
template<class StateT>
__global__ void lfsr113_rocrand_kernel(unsigned int* output,
                                       const size_t  size,
                                       const uint4   seed = uint4{ROCRAND_LFSR113_DEFAULT_SEED_X,
                                                                ROCRAND_LFSR113_DEFAULT_SEED_Y,
                                                                ROCRAND_LFSR113_DEFAULT_SEED_Z,
                                                                ROCRAND_LFSR113_DEFAULT_SEED_W})
{
    const unsigned int tid    = blockIdx.x * blockDim.x + threadIdx.x;
    const unsigned int stride = gridDim.x * blockDim.x;

    StateT             state;
    const unsigned int subsequence = tid;
    rocrand_init(seed, subsequence, &state);

    unsigned int index = tid;
    while(index < size)
    {
        output[index] = rocrand(&state);
        index += stride;
    }
}

int main()
{
    typedef rocrand_state_xorwow  state_t;
    typedef rocrand_state_mtgp32  mtgp32_state_t;
    typedef rocrand_state_lfsr113 lfsr113_state_t;

    const size_t output_size = 1000; /*number of values to generate*/

    // 1. Allocate device output buffers.
    unsigned int* d_output;
    unsigned int* d_mtgp32_output;
    unsigned int* d_lfsr113_output;

    HIP_CHECK(hipMalloc(&d_output, output_size * sizeof(*d_output)));
    HIP_CHECK(hipMalloc(&d_mtgp32_output, output_size * sizeof(*d_mtgp32_output)));
    HIP_CHECK(hipMalloc(&d_lfsr113_output, output_size * sizeof(*d_lfsr113_output)));

    // 2. For MTGP32, allocate states (as many as thread blocks in the grid).
    mtgp32_state_t* mtgp32_states;
    HIP_CHECK(hipMalloc(&mtgp32_states, sizeof(mtgp32_state_t) * 4));
    ROCRAND_CHECK(rocrand_make_state_mtgp32(mtgp32_states, mtgp32dc_params_fast_11213, 4, 0));

    HIP_CHECK(hipDeviceSynchronize());

    // 3. Generate values.
    const dim3 block_size(64);
    const dim3 grid_size(4);

    std::cout << "Launching rocrand_kernel...";

    rocrand_kernel<state_t><<<grid_size, block_size>>>(d_output, output_size);
    HIP_CHECK(hipGetLastError());

    std::cout << "done. \nLaunching mtgp32_rocrand_kernel...";

    // With MTGP32.
    mtgp32_rocrand_kernel<<<grid_size, block_size, 0, 0>>>(mtgp32_states,
                                                           d_mtgp32_output,
                                                           output_size);
    HIP_CHECK(hipGetLastError());

    std::cout << "done. \nLaunching lfsr113_rocrand_kernel...";

    // With LFSR113.
    lfsr113_rocrand_kernel<lfsr113_state_t>
        <<<grid_size, block_size>>>(d_lfsr113_output, output_size);
    HIP_CHECK(hipGetLastError());

    std::cout << "done. \nCopying results to host...";

    // 4. Copy outputs from device to host and free device memory.
    std::vector<unsigned int> h_output(output_size);
    HIP_CHECK(hipMemcpy(h_output.data(),
                        d_output,
                        output_size * sizeof(*d_output),
                        hipMemcpyDeviceToHost));

    // MTGP32
    std::vector<unsigned int> h_mtgp32_output(output_size);
    HIP_CHECK(hipMemcpy(h_mtgp32_output.data(),
                        d_mtgp32_output,
                        output_size * sizeof(*d_mtgp32_output),
                        hipMemcpyDeviceToHost));

    // LFSR113
    std::vector<unsigned int> h_lfsr113_output(output_size);
    HIP_CHECK(hipMemcpy(h_lfsr113_output.data(),
                        d_lfsr113_output,
                        output_size * sizeof(*d_lfsr113_output),
                        hipMemcpyDeviceToHost));

    HIP_CHECK(hipDeviceSynchronize());
    HIP_CHECK(hipFree(d_output));
    HIP_CHECK(hipFree(d_mtgp32_output));
    HIP_CHECK(hipFree(mtgp32_states));
    HIP_CHECK(hipFree(d_lfsr113_output));

    std::cout << "done. \nValidating results...";

    // 5. Check uniformity of results.
    double mean = 0.f;
    if((mean = is_not_uniform_dist(h_output)))
    {
        std::cout << "Validation failed! The normalized mean of the generated values should be "
                     "near 0.5 but it's "
                  << mean << std::endl;
        return error_exit_code;
    }

    // MTGP32
    if((mean = is_not_uniform_dist(h_mtgp32_output)))
    {
        std::cout << "Validation failed! The normalized mean of the MTGP32-generated values should "
                     "be near 0.5 but it's "
                  << mean << std::endl;
        return error_exit_code;
    }

    // LFSR113
    if((mean = is_not_uniform_dist(h_lfsr113_output)))
    {
        std::cout
            << "Validation failed! The normalized mean of the LFSR113-generated values should "
               "be near 0.5 but it's "
            << mean << std::endl;
        return error_exit_code;
    }

    std::cout << "Validation succeded!" << std::endl;
    return 0;
}
